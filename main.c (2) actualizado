/*
 * Proyecto 1, Digital 2
 *
 * Created: 2/10/2026 10:09:51 AM
 * Author : William Melgar Pineda
 * Carnet : 22083
 */ 

// Librerias
#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include "LCD.h"
#include "I2C.h"
#include "UART.h"

#define slave1 0x30
#define slave2 0x31
#define AHT10 0x38

#define slave1R ((0x30 << 1) | 0x01)
#define slave1W ((0x30 << 1) | 0x00)

#define slave2R ((0x31 << 1) | 0x01)
#define slave2W ((0x31 << 1) | 0x00)

#define AHT10_R ((0x38 << 1) | 0x01)
#define AHT10_W ((0x38 << 1) | 0x00)


uint8_t direccion;
uint8_t buffer1;
uint8_t buffer2;
uint8_t a = 0;
uint8_t b = 0;
uint8_t C0, C1, C2, C3, C4, C5 = 0;

static void LCD_print1023(uint16_t x)
{
	LCD_caracter('0' + (x / 1000));        // miles
	LCD_caracter('0' + ((x / 100) % 10));  // centenas
	LCD_caracter('0' + ((x / 10) % 10));   // decenas
	LCD_caracter('0' + (x % 10));          // unidades
}

int main(void)
{
	
	DDRB |= (1 << PB2);   // PB2 como salida
	PORTB &= ~(1 << PB2);
	
	DDRB |= (1 << PORTB5);
	PORTB &= ~(1 << PORTB5);
	
	I2C_MASTER_INIT(100000,1); // iniciarlo como master a 100kHz, Prescaler 1
	
	_delay_ms(50);
	inicioLCD_8bits();
	LCD_cursor(3,1);
	LCD_cadena("S1:");
	_delay_ms(500);
	
	LCD_cursor(8,1);
	LCD_cadena("S2:");
	_delay_ms(500);
	
	LCD_cursor(13,1);
	LCD_cadena("S3:");
	_delay_ms(500);
	//PORTB |= (1 << PORTB2);

	while(1)
	{
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		if (!I2C_MASTER_START())
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		if(!I2C_MASTER_WRITE(slave1W))
		 {
			 I2C_MASTER_STOP();
			 continue;
		}
		if (!I2C_MASTER_WRITE('R'))
		{
			
			I2C_MASTER_STOP();
			continue;
		}
		if(!I2C_MASTER_REPEATEDSTART())
		{
			I2C_MASTER_STOP();
			continue;
		}
		if(!I2C_MASTER_WRITE(slave1R))
		{
			I2C_MASTER_STOP();
			continue;
		}
		if (!I2C_MASTER_READ(&a, 0))
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		I2C_MASTER_STOP();
		
		_delay_ms(250);
		
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		if (!I2C_MASTER_START())
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		if(!I2C_MASTER_WRITE(slave2W))
		{
			I2C_MASTER_STOP();
			continue;
		}
		if (!I2C_MASTER_WRITE('W'))
		{
			
			I2C_MASTER_STOP();
			continue;
		}
		if(!I2C_MASTER_REPEATEDSTART())
		{
			I2C_MASTER_STOP();
			continue;
		}
		if(!I2C_MASTER_WRITE(slave2R))
		{
			I2C_MASTER_STOP();
			continue;
		}
		if (!I2C_MASTER_READ(&b, 0))
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		I2C_MASTER_STOP();
		
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		if (!I2C_MASTER_START())
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		if(!I2C_MASTER_WRITE(AHT10_W))
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		if (!I2C_MASTER_WRITE(0xAC)) 
		{ 
			I2C_MASTER_STOP(); 
			continue; 
		}
		if (!I2C_MASTER_WRITE(0x33)) 
		{
			 I2C_MASTER_STOP();
			  continue;
		 }
		if (!I2C_MASTER_WRITE(0x00))
		{ 
			I2C_MASTER_STOP();
			continue; 
		}
		
		I2C_MASTER_STOP();
		
		_delay_ms(90);
			
		if(!I2C_MASTER_START())
		{
			I2C_MASTER_STOP();
			continue;
		}
		if(!I2C_MASTER_WRITE(AHT10_R))
		{
			I2C_MASTER_STOP();
			continue;
		}
		// primer byte
		if (!I2C_MASTER_READ(&C0, 1))
		{
			I2C_MASTER_STOP();
			continue;
		}
		// segundo byte
		if (!I2C_MASTER_READ(&C1, 1))
		{
			I2C_MASTER_STOP();
			continue;
		}
		// tercer byte
		if (!I2C_MASTER_READ(&C2, 1))
		{
			I2C_MASTER_STOP();
			continue;
		}
		// cuarto byte
		if (!I2C_MASTER_READ(&C3, 1))
		{
			I2C_MASTER_STOP();
			continue;
		}
		// quinto byte
		if (!I2C_MASTER_READ(&C4, 1))
		{
			I2C_MASTER_STOP();
			continue;
		}
		// sexto byte
		if (!I2C_MASTER_READ(&C5, 0))
		{
			I2C_MASTER_STOP();
			continue;
		}
		
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		I2C_MASTER_STOP();
		
		
		LCD_cursor(2,2);
		LCD_print1023(a);
		
		LCD_cursor(7,2);
		LCD_print1023(b);
		
		uint32_t S_RH = ((uint8_t) C1 << 12) | ((uint32_t) C2 << 4) | ((C3 & 0xF0) >> 4); 
		uint8_t RH = (uint8_t)((S_RH*100UL) >> 20);
		
		LCD_cursor(13,2);
		
		if (RH >= 45)
		{
			LCD_cadena("WET ");
		}
		else
		{
			LCD_cadena("DRY ");
		}
		_delay_ms(200);
		
	}
}
